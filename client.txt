import socket
import threading
import secrets
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

def generate_rsa_keys():
    """Generate RSA key pair for authentication and session key exchange."""
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()
    return private_key, public_key

def encrypt_with_rsa(public_key, data):
    """Encrypt data using RSA public key."""
    return public_key.encrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

def decrypt_with_rsa(private_key, encrypted_data):
    """Decrypt RSA encrypted data."""
    return private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

def encrypt_with_aes(session_key, plaintext):
    """Encrypt message using AES-GCM."""
    iv = secrets.token_bytes(12)
    cipher = Cipher(algorithms.AES(session_key), modes.GCM(iv))
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    return iv + encryptor.tag + ciphertext  # Return IV + tag + ciphertext

def decrypt_with_aes(session_key, encrypted_message):
    """Decrypt AES-GCM encrypted message."""
    iv = encrypted_message[:12]
    tag = encrypted_message[12:28]
    ciphertext = encrypted_message[28:]
    cipher = Cipher(algorithms.AES(session_key), modes.GCM(iv, tag))
    decryptor = cipher.decryptor()
    return decryptor.update(ciphertext) + decryptor.finalize()

def receive_messages(client_socket, private_key, session_key):
    """Receive and decrypt messages from other clients."""
    while True:
        try:
            encrypted_message = client_socket.recv(4096)
            if not encrypted_message:
                break
            decrypted_message = decrypt_with_aes(session_key, encrypted_message)
            print("\nüîì Received:", decrypted_message.decode())
        except Exception as e:
            print("Error receiving message:", e)
            break

def request_peer_public_key(client_socket, peer_addr):
    """Request a peer's public key from the server."""
    client_socket.send(f"GET_PUBLIC_KEY {peer_addr}".encode('utf-8'))
    peer_public_key_pem = client_socket.recv(2048)
    
    if peer_public_key_pem.startswith(b"ERROR"):
        print("‚ùå Error: Peer not found.")
        return None

    return serialization.load_pem_public_key(peer_public_key_pem)

def send_encrypted_session_key(client_socket, peer_addr, encrypted_session_key):
    """Send encrypted session key to peer via the server."""
    client_socket.send(b"SESSION_KEY " + peer_addr.encode() + b" " + encrypted_session_key)

def receive_encrypted_session_key(client_socket, private_key):
    """Receive encrypted session key from the server and decrypt it."""
    encrypted_peer_session_key = client_socket.recv(4096)
    return decrypt_with_rsa(private_key, encrypted_peer_session_key)

def main():
    """Client main function."""
    private_key, public_key = generate_rsa_keys()
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect(("127.0.0.1", 9996))

    # Step 1: Send public key to server
    client_socket.send(public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ))

    print("‚úÖ Authenticated with server")

    # Step 2: Request peer's public key
    peer_addr = input("Enter peer's address: ")
    peer_public_key = request_peer_public_key(client_socket, peer_addr)

    if peer_public_key:
        # Step 3: Encrypt and send session key
        session_key = secrets.token_bytes(32)
        encrypted_session_key = encrypt_with_rsa(peer_public_key, session_key)
        send_encrypted_session_key(client_socket, peer_addr, encrypted_session_key)
        print("\nüîë Encrypted Session Key sent!")

        # Step 4: Receive encrypted session key from peer
        peer_session_key = receive_encrypted_session_key(client_socket, private_key)
        print("‚úÖ Session Key Established")

        # Step 5: Start receiving messages in a separate thread
        threading.Thread(target=receive_messages, args=(client_socket, private_key, peer_session_key), daemon=True).start()

        while True:
            message = input("\nYou: ").encode()
            encrypted_message = encrypt_with_aes(peer_session_key, message)
            client_socket.send(encrypted_message)

if __name__ == "__main__":
    main()
 